
:description: The perfect emulation setup to study and develop the <<linux-kernel>> v5.2.1, kernel modules, <<qemu-buildroot-setup,QEMU>>, <<gem5-buildroot-setup,gem5>> and x86_64, ARMv7 and ARMv8 <<userland-assembly,userland>> and <<baremetal-setup,baremetal>> assembly, <<c,ANSI C>>, <<cpp,C++>> and <<posix,POSIX>>. <<gdb>> and <<kgdb>> just work. Powered by <<about-the-qemu-buildroot-setup,Buildroot>> and <<about-the-baremetal-setup,crosstool-NG>>.  Highly automated. Thoroughly documented. Automated <<test-this-repo,tests>>. "Tested" in an Ubuntu 18.04 host.
:idprefix:
:idseparator: -
:nofooter:
:sectanchors:
:sectlinks:
:sectnumlevels: 6
:sectnums:
:toc-title:
:toc: macro
:toclevels: 6

== La la
....

the script:

....
./asciidoctor/extract-header-ids test.adoc
....

produces:

....
auto-generated
explicitly-given
....

One application we have in mind for this is that as of 2.0.10 Asciidoctor does not warn on header ID collisions between auto-generated IDs: https://github.com/asciidoctor/asciidoctor/issues/3147 But this script doesn't solve that yet as it would require generating the section IDs without the `-N` suffix. Section generation happens at `Section.generate_id` in Asciidoctor code.

Hastily hacked from: https://asciidoctor.org/docs/user-manual/#https://asciidoctor.org/docs/user-manual/#tree-processor-example until I noticed that that example had a bug at the time and so fixed it here: https://github.com/asciidoctor/asciidoctor/issues/3363

[[asciidoctor-link-target-up-rb]]
=== asciidoctor/link-target-up.rb

The Asciidoctor extension scripts:

* link:asciidoctor-link-up.rb
* link:asciidoctor-link-github.rb

hack the README `link:` targets to make them work from:

* inside the `out/` directory with `../`
* <<github-pages>>, with explicit GitHub blob URLs

==== GitHub pages

As mentioned before the TOC, we have to push this README to GitHub pages due to: https://github.com/isaacs/github/issues/1610

For now, instead of pushing with `git push`, I just remember to always push with:

....
./publish-gh-pages
....

Source: link:publish-gh-pages[]

I'm going this way for now because:

* the Jekyll Asciidoctor plugin is not enabled by default on GitHub: https://webapps.stackexchange.com/questions/114606/can-github-pages-render-asciidoc
* https://stackoverflow.com/questions/1797074/local-executing-hook-after-a-git-push[post-push hooks don't exist]
* I'm lazy to setup a proper Travis CI push
* I'm the only contributor essentially, so no problems with pull requests

The only files used by the GitHub pages are:

* link:Gemfile[]
* link:_config.yml[]

=== Clean the build

You did something crazy, and nothing seems to work anymore?

All our build outputs are stored under `out/`, so the coarsest and most effective thing you can do is:

....
rm -rf out
....

This implies a full rebuild for all archs however, so you might first want to explore finer grained cleans first.

All our individual `build-*` scripts have a `--clean` option to completely nuke their builds:

....
./build-gem5 --clean
./build-qemu --clean
./build-buildroot --clean
....

Verify with:

....
ls "$(./getvar qemu_build_dir)"
ls "$(./getvar gem5_build_dir)"
ls "$(./getvar buildroot_build_dir)"
....

Note that host tools like QEMU and gem5 store all archs in a single directory to factor out build objects, so cleaning one arch will clean all of them.

To only nuke only one Buildroot package, we can use the https://buildroot.org/downloads/manual/manual.html#pkg-build-steps[`-dirclean`] Buildroot target:

....
./build-buildroot --no-all -- <package-name>-dirclean
....

e.g.:

....
./build-buildroot --no-all -- sample_package-dirclean
....

Verify with:

....
ls "$(./getvar buildroot_build_build_dir)"
....

=== ccache

https://en.wikipedia.org/wiki/Ccache[ccache] <<benchmark-builds,might>> save you a lot of re-build when you decide to <<clean-the-build>> or create a new <<build-variants,build variant>>.

We have ccache enabled for everything we build by default.

However, you likely want to add the following to your `.bashrc` to take better advantage of `ccache`:

....
export CCACHE_DIR=~/.ccache
export CCACHE_MAXSIZE="20G"
....

We cannot automate this because you have to decide:

* should I store my cache on my HD or SSD?
* how big is my build, and how many build configurations do I need to keep around at a time?

If you don't those variables it, the default is to use `~/.buildroot-ccache` with `5G`, which is a bit small for us.

To check if `ccache` is working, run this command while a build is running on another shell:

....
watch -n1 'make -C "$(./getvar buildroot_build_dir)" ccache-stats'
....

or if you have it installed on host and the environment variables exported simply with:

....
watch -n1 'ccache -s'
....

and then watch the miss or hit counts go up.

We have https://buildroot.org/downloads/manual/manual.html#ccache[enabled ccached] builds by default.

`BR2_CCACHE_USE_BASEDIR=n` is used for Buildroot, which means that:

* absolute paths are used and GDB can find source files
* but builds are not reused across separated LKMC directories

=== Rebuild Buildroot while running

It is not possible to rebuild the root filesystem while running QEMU because QEMU holds the file qcow2 file:

....
error while converting qcow2: Failed to get "write" lock
....

=== Simultaneous runs

When doing long simulations sweeping across multiple system parameters, it becomes fundamental to do multiple simulations in parallel.

This is specially true for gem5, which runs much slower than QEMU, and cannot use multiple host cores to speed up the simulation: https://github.com/cirosantilli-work/gem5-issues/issues/15[], so the only way to parallelize is to run multiple instances in parallel.

This also has a good synergy with <<build-variants>>.

First shell:

....
./run
....

Another shell:

....
./run --run-id 1
....

and now you have two QEMU instances running in parallel.

The default run id is `0`.

Our scripts solve two difficulties with simultaneous runs:

* port conflicts, e.g. GDB and link:gem5-shell[]
* output directory conflicts, e.g. traces and gem5 stats overwriting one another

Each run gets a separate output directory. For example:

....
./run --arch aarch64 --emulator gem5 --run-id 0 &>/dev/null &
./run --arch aarch64 --emulator gem5 --run-id 1 &>/dev/null &
....

produces two separate <<m5out-directory,`m5out` directories>>:

....
echo "$(./getvar --arch aarch64 --emulator gem5 --run-id 0 m5out_dir)"
echo "$(./getvar --arch aarch64 --emulator gem5 --run-id 1 m5out_dir)"
....

and the gem5 host executable stdout and stderr can be found at:

....
less "$(./getvar --arch aarch64 --emulator gem5 --run-id 0 termout_file)"
less "$(./getvar --arch aarch64 --emulator gem5 --run-id 1 termout_file)"
....

Each line is prepended with the timestamp in seconds since the start of the program when it appeared.

To have more semantic output directories names for later inspection, you can use a non numeric string for the run ID, and indicate the port offset explicitly:

....
./run --arch aarch64 --emulator gem5 --run-id some-experiment --port-offset 1
....

`--port-offset` defaults to the run ID when that is a number.

Like <<cpu-architecture>>, you will need to pass the `-n` option to anything that needs to know runtime information, e.g. <<gdb>>:

....
./run --run-id 1
./run-gdb --run-id 1
....

To run multiple gem5 checkouts, see: xref:gem5-worktree[xrefstyle=full].

Implementation note: we create multiple namespaces for two things:

* run output directory
* ports
** QEMU allows setting all ports explicitly.
+
If a port is not free, it just crashes.
+
We assign a contiguous port range for each run ID.
** gem5 automatically increments ports until it finds a free one.
+
gem5 60600f09c25255b3c8f72da7fb49100e2682093a does not seem to expose a way to set the terminal and VNC ports from `fs.py`, so we just let gem5 assign the ports itself, and use `-n` only to match what it assigned. Those ports both appear on <<gem5-config-ini>>.
+
The GDB port can be assigned on `gem5.opt --remote-gdb-port`, but it does not appear on `config.ini`.

=== Build variants

It often happens that you are comparing two versions of the build, a good and a bad one, and trying to figure out why the bad one is bad.

Our build variants system allows you to keep multiple built versions of all major components, so that you can easily switching between running one or the other.

==== Linux kernel build variants

If you want to keep two builds around, one for the latest Linux version, and the other for Linux `v4.16`:

....
# Build master.
./build-linux

# Build another branch.
git -C "$(./getvar linux_source_dir)" fetch --tags --unshallow
git -C "$(./getvar linux_source_dir)" checkout v4.16
./build-linux --linux-build-id v4.16

# Restore master.
git -C "$(./getvar linux_source_dir)" checkout -

# Run master.
./run

# Run another branch.
./run --linux-build-id v4.16
....

The `git fetch --unshallow` is needed the first time because `./build --download-dependencies` only does a shallow clone of the Linux kernel to save space and time, see also: https://stackoverflow.com/questions/6802145/how-to-convert-a-git-shallow-clone-to-a-full-clone

The `--linux-build-id` option should be passed to all scripts that support it, much like `--arch` for the <<cpu-architecture>>, e.g. to step debug:

.....
./run-gdb --linux-build-id v4.16
.....

To run both kernels simultaneously, one on each QEMU instance, see: xref:simultaneous-runs[xrefstyle=full].

==== QEMU build variants

Analogous to the <<linux-kernel-build-variants>> but with the `--qemu-build-id` option instead:

....
./build-qemu
git -C "$(./getvar qemu_source_dir)" checkout v2.12.0
./build-qemu --qemu-build-id v2.12.0
git -C "$(./getvar qemu_source_dir)" checkout -
./run
./run --qemu-build-id v2.12.0
....

==== gem5 build variants

Analogous to the <<linux-kernel-build-variants>> but with the `--gem5-build-id` option instead:

....
# Build master.
./build-gem5

# Build another branch.
git -C "$(./getvar gem5_source_dir)" checkout some-branch
./build-gem5 --gem5-build-id some-branch

# Restore master.
git -C "$(./getvar gem5_source_dir)" checkout -

# Run master.
./run --emulator gem5

# Run another branch.
git -C "$(./getvar gem5_source_dir)" checkout some-branch
./run --gem5-build-id some-branch --emulator gem5
....

Don't forget however that gem5 has Python scripts in its source code tree, and that those must match the source code of a given build.

Therefore, you can't forget to checkout to the sources to that of the corresponding build before running, unless you explicitly tell gem5 to use a non-default source tree with <<gem5-worktree>>. This becomes inevitable when you want to launch multiple simultaneous runs at different checkouts.

===== gem5 worktree

<<gem5-build-variants,`--gem5-build-id`>> goes a long way, but if you want to seamlessly switch between two gem5 tress without checking out multiple times, then `--gem5-worktree` is for you.

....
# Build gem5 at the revision in the gem5 submodule.
./build-gem5

# Create a branch at the same revision as the gem5 submodule.
./build-gem5 --gem5-worktree my-new-feature
cd "$(./getvar --gem5-worktree my-new-feature)"
vim create-bugs
git add .
git commit -m 'Created a bug'
cd -
./build-gem5 --gem5-worktree my-new-feature

# Run the submodule.
./run --emulator gem5 --run-id 0 &>/dev/null &

# Run the branch the need to check out anything.
# With --gem5-worktree, we can do both runs at the same time!
./run --emulator gem5 --gem5-worktree my-new-feature --run-id 1 &>/dev/null &
....

`--gem5-worktree <worktree-id>` automatically creates:

* a https://git-scm.com/docs/git-worktree[Git worktree] of gem5 if one didn't exit yet for `<worktree-id>`
* a separate build directory, exactly like `--gem5-build-id my-new-feature` would

We promise that the scripts sill never touch that worktree again once it has been created: it is now up to you to manage the code manually.

`--gem5-worktree` is required if you want to do multiple simultaneous runs of different gem5 versions, because each gem5 build needs to use the matching Python scripts inside the source tree.

The difference between `--gem5-build-id` and `--gem5-worktree` is that `--gem5-build-id` specifies only the gem5 build output directory, while `--gem5-worktree` specifies the source input directory.

Each Git worktree needs a branch name, and we append the `wt/` prefix to the `--gem5-worktree` value, where `wt` stands for `WorkTree`. This is done to allow us to checkout to a test `some-branch` branch under `submodules/gem5` and still use `--gem5-worktree some-branch`, without conflict for the worktree branch, which can only be checked out once.

===== gem5 private source trees

Suppose that you are working on a private fork of gem5, but you want to use this repository to develop it as well.

Simply adding your private repository as a remote to `submodules/gem5` is dangerous, as you might forget and push your private work by mistake one day.

Even removing remotes is not safe enough, since `git submodule update` and other submodule commands can restore the old public remote.

Instead, we provide the following safer process.

First do a separate private clone of you private repository outside of this repository:

....
git clone https://my.private.repo.com/my-fork/gem5.git gem5-internal
gem5_internal="$(pwd)/gem5-internal"
....

Next, when you want to build with the private repository, use the `--gem5-build-dir` and  `--gem5-source-dir` argument to override our default gem5 source and build locations:

....
cd linux-kernel-module-cheat
./build-gem5 \
  --gem5-build-dir "${gem5_internal}/build" \
  --gem5-source-dir "$gem5_internal" \
;
./run-gem5 \
  --gem5-build-dir "${gem5_internal}/build" \
  --gem5-source-dir "$gem5_internal" \
;
....

With this setup, both your private gem5 source and build are safely kept outside of this public repository.

==== Buildroot build variants

Allows you to have multiple versions of the GCC toolchain or root filesystem.

Analogous to the <<linux-kernel-build-variants>> but with the `--build-id` option instead:

....
./build-buildroot
git -C "$(./getvar buildroot_source_dir)" checkout 2018.05
./build-buildroot --buildroot-build-id 2018.05
git -C "$(./getvar buildroot_source_dir)" checkout -
./run
./run --buildroot-build-id 2018.05
....

=== Directory structure

==== lkmc directory

link:lkmc/[] contains sources and headers that are shared across kernel modules, userland and baremetal examples.

We chose this awkward name so that our includes will have an `lkmc/` prefix.

Another option would have been to name it as `includes/lkmc`, but that would make paths longer, and we might want to store source code in that directory as well in the future.

===== Userland objects vs header-only

When factoring out functionality across userland examples, there are two main options:

* use header-only implementations
* use separate C files and link to separate objects.

The downsides of the header-only implementation are:

* slower compilation time, especially for C++
* cannot call C implementations from assembly files

The advantages of header-only implementations are:

* easier to use, just `#include` and you are done, no need to modify build metadata.

As a result, we are currently using the following rule:

* if something is only going to be used from C and not assembly, define it in a header which is easier to use
+
The slower compilation should be OK as long as split functionality amongst different headers and only include the required ones.
+
Also we don't have a choice in the case of C++ template, which must stay in headers.
* if the functionality will be called from assembly, then we don't have a choice, and must add it to a separate source file and link against it.

==== buildroot_packages directory

Source: link:buildroot_packages/[]

Every directory inside it is a Buildroot package.

Those packages get automatically added to Buildroot's `BR2_EXTERNAL`, so all you need to do is to turn them on during build, e.g.:

....
./build-buildroot --config 'BR2_PACKAGE_SAMPLE_PACKAGE=y'
....

then test it out with:

....
./run --eval-after './sample_package.out'
....

and you should see:

....
hello sample_package
....

Source: link:buildroot_packages/sample_package/sample_package.c[]

You can force a rebuild with:

....
./build-buildroot --config 'BR2_PACKAGE_SAMPLE_PACKAGE=y' -- sample_package-reconfigure
....

Buildroot packages are convenient, but in general, if a package if very important to you, but not really mergeable back to Buildroot, you might want to just use a custom build script for it, and point it to the Buildroot toolchain, and then use `BR2_ROOTFS_OVERLAY`, much like we do for <<userland-setup>>.

A custom build script can give you more flexibility: e.g. the package can be made work with other root filesystems more easily, have better <<9p>> support, and rebuild faster as it evades some Buildroot boilerplate.

===== kernel_modules buildroot package

Source: link:buildroot_packages/kernel_modules/[]

An example of how to use kernel modules in Buildroot.

Usage:

....
./build-buildroot \
  --build-linux \
  --config 'BR2_PACKAGE_KERNEL_MODULES=y' \
  --no-overlay \
  -- \
  kernel_modules-reconfigure \
;
....

Then test one of the modules with:

....
./run --buildroot-linux --eval-after 'modprobe buildroot_hello'
....

Source: link:buildroot_packages/kernel_modules/buildroot_hello.c[]

As you have just seen, this sets up everything so that <<modprobe>> can correctly find the module.

`./build-buildroot --build-linux` and `./run --buildroot-linux` are needed because the Buildroot kernel modules must use the Buildroot Linux kernel at build and run time.

The `--no-overlay` is required otherwise our `modules.order` generated by `./build-linux` and installed with `BR2_ROOTFS_OVERLAY` overwrites the Buildroot generated one.

Implementattion described at: https://stackoverflow.com/questions/40307328/how-to-add-a-linux-kernel-driver-module-as-a-buildroot-package/43874273#43874273

==== patches directory

[[patches-global-directory]]
===== patches/global directory

Has the following structure:

....
package-name/00001-do-something.patch
....

The patches are then applied to the corresponding packages before build.

Uses `BR2_GLOBAL_PATCH_DIR`.

[[patches-manual-directory]]
===== patches/manual directory

Patches in this directory are never applied automatically: it is up to users to manually apply them before usage following the instructions in this documentation.

These are typically patches that don't contain fundamental functionality, so we don't feel like forking the target repos.

==== rootfs_overlay

We use this directory for:

* customized configuration files
* userland module test scripts that don't need to be compiled.
+
Contrast this with <<userland-content,C examples>> that need compilation.

This directory is copied into the target filesystem by:

....
./copy-overlay
./build-buildroot
....

Source: link:copy-overlay[]

Build Buildroot is required for the same reason as described at: xref:your-first-kernel-module-hack[xrefstyle=full].

However, since the link:rootfs_overlay[] directory does not require compilation, unlike say <<your-first-kernel-module-hack,kernel modules>>, we also make it <<9p>> available to the guest directly even without `./copy-overlay` at:

....
ls /mnt/9p/rootfs_overlay
....

This way you can just hack away the scripts and try them out immediately without any further operations.

==== lkmc.c

The files:

* link:lkmc.c[]
* link:lkmc.h[]

contain common C function helpers that can be used both in userland and baremetal. Oh, the infinite <<about-the-baremetal-setup,joys of Newlib>>.

Those files also contain arch specific helpers under ifdefs like:

....
#if defined(__aarch64__)
....

We try to keep as much as possible in those files. It bloats builds a little, but just makes everything simpler to understand.

==== rand_check.out

Print out several parameters that normally change randomly from boot to boot:

....
./run --eval-after './linux/rand_check.out;./linux/poweroff.out'
....

Source: link:userland/linux/rand_check.c[]

This can be used to check the determinism of:

* <<norandmaps>>
* <<qemu-record-and-replay>>

==== lkmc_home

`lkmc_home` refers to the target base directory in which we put all our custom built stuff, such as <<userland-setup,userland executables>> and <<your-first-kernel-module-hack,kernel modules>>.

The current value can be found with:

....
./getvar guest_lkmc_home
....

In the past, we used to dump everything into the root filesystem, but as the userland structure got more complex with subfolders, we decided that the risk of conflicting with important root files was becoming too great.

To save you from typing that path every time, we have made our most common commands `cd` into that directory by default for you, e.g.:

* interactive shells `cd` there through <<busybox-shell-initrc-files>>
* `--eval` and `--eval-after` through <<replace-init>> and <<init-busybox>>

Whenever a relative path is used inside a guest sample command, e.g. `insmod hello.ko` or `./hello.out`, it means that the path lives in `lkmc_home` unless stated otherwise.

=== Test this repo

==== Automated tests

Run almost all tests:

....
./build-test --all-archs --all-emulators --size 3 && \
./test --size 3
echo $?
....

should output 0.

Sources:

* link:build-test[]
* link:test[]

The link:test[] script runs several different types of tests, which can also be run separately as explained at:

* link:test-boot[]
* <<test-userland-in-full-system>>
* <<user-mode-tests>>
* <<baremetal-tests>>
* <<gdb-tests>>
* <<gem5-unit-tests>>

link:test[] does not all possible tests, because there are too many possible variations and that would take forever. The rationale is the same as for `./build all` and is explained in `./build --help`.

===== Test arch and emulator selection

You can select multiple archs and emulators of interest, as for an other command, with:

....
./test-executables \
  --arch x86_64 \
  --arch aarch64 \
  --emulator gem5 \
  --emulator qemu \
;
....

You can also test all supported archs and emulators with:

....
./test-executables \
  --all-archs \
  --all-emulators \
;
....

This command would run the test four times, using `x86_64` and `aarch64` with both gem5 and QEMU.

Without those flags, it defaults to just running the default arch and emulator once: `x86_64` and `qemu`.

===== Quit on fail

By default, continue running even after the first failure happens, and they show a summary at the end.

You can make them exit immediately with the `--no-quit-on-fail` option, e.g.:

....
./test-executables --quit-on-fail
....

===== Test userland in full system

TODO: we really need a mechanism to automatically generate the test list automatically e.g. based on <<path-properties>>, currently there are many tests missing, and we have to add everything manually which is very annoying.

We could just generate it on the fly on the host, and forward it to guest through CLI arguments.

Run all userland tests from inside full system simulation (i.e. not <<user-mode-simulation>>):

....
./test-userland-full-system
....

This includes, in particular, userland programs that test the kernel modules, which cannot be tested in user mode simulation.

Basically just boots and runs: link:rootfs_overlay/lkmc/test_all.sh[]

Failure is detected by looking for the <<magic-failure-string>>

Most userland programs that don't rely on kernel modules can also be tested in user mode simulation as explained at: xref:user-mode-tests[xrefstyle=full].

===== GDB tests

We have some https://github.com/pexpect/pexpect[pexpect] automated tests for GDB for both userland and baremetal programs!

Run the userland tests:

....
./build --all-archs test-gdb && \
./test-gdb --all-archs --all-emulators
....

Run the baremetal tests instead:

....
./test-gdb --all-archs --all-emulators --mode baremetal
....

Sources:

* link:test-gdb[]
* link:userland/gdb_tests/[]
* link:userland/arch/arm/gdb_tests/[]
* link:userland/arch/aarch64/gdb_tests/[]

If a test fails, re-run the test commands manually and use `--verbose` to understand what happened:

....
./run --arch arm --background --baremetal baremetal/c/add.c --gdb-wait &
./run-gdb --arch arm --baremetal baremetal/c/add.c --verbose -- main
....

and possibly repeat the GDB steps manually with the usual:

....
./run-gdb --arch arm --baremetal baremetal/c/add.c --no-continue --verbose
....

To debug GDB problems on gem5, you might want to enable the following <<gem5-tracing,tracing>> options:

....
./run \
  --arch arm \
  --baremetal baremetal/c/add.c \
  --gdb-wait \
  --trace GDBRecv,GDBSend \
  --trace-stdout \
;
....

===== Magic failure string

We do not know of any way to set the emulator exit status in QEMU arm full system.

For other arch / emulator combinations, we know how to do it:

* aarch64: aarch64 semihosting supports exit status
* gem5: <<m5-fail>> works on all archs
* user mode: QEMU forwards exit status, for gem5 we do some log parsing as described at: xref:gem5-syscall-emulation-exit-status[xrefstyle=full]

Since we can't do it for QEMU arm, the only reliable solution is to just parse the guest serial output for a magic failure string to check if tests failed.

Our run scripts parse the serial output looking for a line line containing only exactly the magic regular expression:

....
lkmc_exit_status_(\d+)
....

and then exit with the given regular expression, e.g.:

....
./run --arch aarch64 baremetal/return2.c
echo $?
....

should output:

....
2
....

This magic output string is notably generated by:

* link:rootfs_overlay/lkmc/test_fail.sh[], which is used by <<test-userland-in-full-system>>
* the `exit()` baremetal function when `status != 1`.
+
Unfortunately the only way we found to set this up was with `on_exit`: https://github.com/cirosantilli/linux-kernel-module-cheat/issues/59[].
+
Trying to patch `_exit` directly fails since at that point some de-initialization has already happened which prevents the print.
+
So setup this `on_exit` automatically from all our <<baremetal-bootloaders>>, so it just works automatically for the examples that use the bootloaders: https://stackoverflow.com/questions/44097610/pass-parameter-to-atexit/49659697#49659697
+
The following examples end up testing that our setup is working:
+
* link:userland/c/assert_fail.c[]
* link:userland/c/return0.c[]
* link:userland/c/return1.c[]
* link:userland/c/return2.c[]
* link:userland/c/exit0.c[]
* link:userland/c/exit1.c[]
* link:userland/c/exit2.c[]
* link:userland/posix/kill.c[]

Beware that on Linux kernel simulations, you cannot even echo that string from userland, since userland stdout shows up on the serial.

==== Non-automated tests

===== Test GDB Linux kernel

For the Linux kernel, do the following manual tests for now.

Shell 1:

....
./run --gdb-wait
....

Shell 2:

....
./run-gdb start_kernel
....

Should break GDB at `start_kernel`.

Then proceed to do the following tests:

* `./count.sh` and `break __x64_sys_write`
* `insmod timer.ko` and `break lkmc_timer_callback`

===== Test the Internet

You should also test that the Internet works:

....
./run --arch x86_64 --kernel-cli '- lkmc_eval="ifup -a;wget -S google.com;poweroff;"'
....

===== CLI script tests

`build-userland` and `test-executables` have a wide variety of target selection modes, and it was hard to keep them all working without some tests:

* link:test-build-userland[]
* link:test-test-executables[]

=== Bisection

When updating the Linux kernel, QEMU and gem5, things sometimes break.

However, for many types of crashes, it is trivial to bisect down to the offending commit, in particular because we can make QEMU and gem5 exit with status 1 on kernel panic as mentioned at: xref:exit-emulator-on-panic[xrefstyle=full].

For example, when updating from QEMU `v2.12.0` to `v3.0.0-rc3`, the Linux kernel boot started to panic for `arm`.

We then bisected it as explained at: https://stackoverflow.com/questions/4713088/how-to-use-git-bisect/22592593#22592593 with the link:bisect-qemu-linux-boot[] script:

....
root_dir="$(pwd)"
cd "$(./getvar qemu_source_dir)"
git bisect start

# Check that our test script fails on v3.0.0-rc3 as expected, and mark it as bad.
"${root_dir}/bisect-qemu-linux-boot"
# Should output 1.
echo #?
git bisect bad

# Same for the good end.
git checkout v2.12.0
"${root_dir}/bisect-qemu-linux-boot"
# Should output 0.
echo #?
git bisect good

# This leaves us at the offending commit.
git bisect run "${root_dir}/bisect-qemu-linux-boot"

# Clean up after the bisection.
git bisect reset
git submodule update
"${root_dir}/build-qemu" --clean --qemu-build-id bisect
....

Other bisection helpers include:

* link:bisect-linux-boot-gem5[]
* link:bisect-gem5-linux-boot[]

[[path-properties]]
=== path_properties

In order to build and run each userland and <<baremetal-setup,baremetal>> example properly, we need per-file metadata such as compiler flags and required number of cores.

This data is stored is stored in link:path_properties.py[] at `path_properties_tuples`.

Maybe we should embed it magically into source files directories to make it easier to see? But one big Python dict was easier to implement so we started like this. And it allows factoring chunks out easily.

The format is as follows:

....
'path_component': (
    {'property': value},
    {
        'child_path_component':
        {
            {'child_property': },
            {}
        }
    }
)
....

and as a shortcut, paths that don't have any children can be written directly as:

.....
'path_component': {'property': value}
.....

Properties of parent directories apply to all children.

Lists coming from parent directories are extended instead of overwritten by children, this is especially useful for C compiler flags.

=== Update a forked submodule

This is a template update procedure for submodules for which we have some patches on on top of mainline.

This example is based on the Linux kernel, for which we used to have patches, but have since moved to mainline:

....
# Last point before out patches.
last_mainline_revision=v4.15
next_mainline_revision=v4.16
cd "$(./getvar linux_source_dir)"

# Create a branch before the rebase in case things go wrong.
git checkout -b "lkmc-${last_mainline_revision}"
git remote set-url origin git@github.com:cirosantilli/linux.git
git push
git checkout master

git remote add up git://git.kernel.org/pub/scm/linux/kernel/git/stable/linux-stable.git
git fetch up
git rebase --onto "$next_mainline_revision" "$last_mainline_revision"

# And update the README to show off.
git commit -m "linux: update to ${next_mainline_revision}"
....

=== Release

==== Release procedure

Ensure that the <<automated-tests>> are passing on a clean build:

....
mv out out.bak
./build-test --size 3 && ./test --size 3
....

The `./build-test` command builds a superset of what will be downloaded which also tests other things we would like to be working on the release. For the minimal build to generate the files to be uploaded, see: xref:release-zip[xrefstyle=full]

The clean build is necessary as it generates clean images since <<remove-buildroot-packages,it is not possible to remove Buildroot packages>>

Run all tests in <<non-automated-tests>> just QEMU x86_64 and QEMU aarch64.

TODO: not working currently, so skipped: Ensure that the <<benchmark-this-repo,benchmarks>> look fine:

....
./bench-all -A
....

Create a release candidate and upload it:

....
git tag -a -m '' v3.0-rc1
git push --follow-tags
./release-zip --all-archs
# export LKMC_GITHUB_TOKEN=<your-token>
./release-upload
....

Now let's do an out-of-box testing for the release candidate:

....
cd ..
git clone https://github.com/cirosantilli/linux-kernel-module-cheat linux-kernel-module-cheat-release
cd linux-kernel-module-cheat-release
....

Test <<prebuilt>>.

Clean up, and re-start from scratch:

....
cd ..
rm -rf linux-kernel-module-cheat-release
git clone https://github.com/cirosantilli/linux-kernel-module-cheat linux-kernel-module-cheat-release
cd linux-kernel-module-cheat-release
....

Go through all the other <<getting-started>> sections in order.

Once everything looks fine, publish the release with:

....
git tag -a  v3.0
# Describe the release int the tag message.
git push --follow-tags
./release-zip --all-archs
# export LKMC_GITHUB_TOKEN=<your-token>
./release-upload
....

==== release-zip

Create a zip containing all files required for <<prebuilt>>:

....
./build --all-archs release && ./release-zip --all-archs
....

Source: link:release-zip[]

This generates a zip file:

....
echo "$(./getvar release_zip_file)"
....

which you can then upload somewhere.

==== release-upload

After:

* running <<release-zip>>
* creating and pushing a tag to GitHub

you can upload the release to GitHub automatically with:

....
# export LKMC_GITHUB_TOKEN=<your-token>
./release-upload
....

Source: link:release-upload[]

The HEAD of the local repository must be on top of a tag that has been pushed for this to work.

Create `LKMC_GITHUB_TOKEN` under: https://github.com/settings/tokens/new and save it to your `.bashrc`.

The implementation of this script is described at:

* https://stackoverflow.com/questions/5207269/how-to-release-a-build-artifact-asset-on-github-with-a-script/52354732#52354732
* https://stackoverflow.com/questions/38153418/can-someone-give-a-python-requests-example-of-uploading-a-release-asset-in-githu/52354681#52354681

=== Design rationale

==== Design goals

This project was created to help me understand, modify and test low level system components by using system simulators.

System simulators are cool compared to real hardware because they are:

* free
* make experiments highly reproducible
* give full visibility to the system: you can inspect any byte in memory, or the state of any hardware register. The laws of physics sometimes get in the way when doing that for real hardware.

The current components we focus the most on are:

* <<linux-kernel>> and Linux kernel modules
* full systems emulators, currently <<qemu-buildroot-setup,qemu>> and <<gem5-buildroot-setup,gem5>>
* <<buildroot>>. We use and therefore document, a large part of its feature set.

The following components are not covered, but they would also benefit from this setup, and it shouldn't be hard to add them:

* C standard libraries
* compilers. Project idea: add a new instruction to x86, then hack up GCC to actually use it, and make a C program that generates it.

The design goals are to provide setups that are:

* highly automated: "just works"
* thoroughly documented: you know what "just works" means
* can be fully built from source: to give visibility and allow modifications
* can also use <<prebuilt, prebuilt binaries>> as much as possible: in case you are lazy or unable to build from source

We aim to make a documentation that contains a very high runnable example / theory bullshit ratio.

Having at least one example per section is ideal, and it should be the very first thing in the section if possible.

==== Setup trade-offs

The trade-offs between the different <<getting-started,setups>> are basically a balance between:

* speed ans size: how long and how much disk space do the build and run take?
* visibility: can you GDB step debug everything and read source code?
* modifiability: can you modify the source code and rebuild a modified version?
* portability: does it work on a Windows host? Could it ever?
* accuracy: how accurate does the simulation represent real hardware?
* compatibility: how likely is is that all the components will work well together: emulator, compiler, kernel, standard library, ...
* guest software availability: how wide is your choice of easily installed guest software packages? See also: xref:linux-distro-choice[xrefstyle=full]

==== Resource tradeoff guidelines

Choosing which features go into our default builds means making tradeoffs, here are our guidelines:

* keep the root filesystem as tiny as possible to make <<prebuilt>> small: only add BusyBox to have a small interactive system.
+
It is easy to add new packages once you have the toolchain, and if you don't there are infinitely many packages to cover and we can't cover them all.
* enable every feature possible on the toolchain (GCC, Binutils), because changes imply Buildroot rebuilds
* runtime is sacred. Faster systems are:
+
--
** easier to understand
** run faster, which is specially for <<gem5>> which is slow
--
+
Runtime basically just comes down to how we configure the Linux kernel, since in the root filesystem all that matters is `init=`, and that is easy to control.
+
One possibility we could play with is to build loadable modules instead of built-in modules to reduce runtime, but make it easier to get started with the modules.

In order to learn how to measure some of those aspects, see: xref:benchmark-this-repo[xrefstyle=full].

==== Linux distro choice

We haven't found the ultimate distro yet, here is a summary table of trade-offs that we care about: xref:table-lkmc-linux-distro-comparison[xrefstyle=full].

[[table-lkmc-linux-distro-comparison]]
.Comparison of Linux distros for usage in this repository
[options="header"]
|===
|Distro |Packages in single Git tree |Git tracked docs |Cross build without QEMU |Prebuilt downloads |Number of packages

|Buildroot 2018.05
|y
|y
|y
|n
|2k (1)

|Ubuntu 18.04
|n
|n
|n
|y
|50k (3)

|Yocto 2.5 (8)
|?
|y (5)
|?
|y (6)
|400 (7)

|Alpine Linux 3.8.0
|y
|n (1)
|?
|y
|2000 (4)

|===

* (1): Wiki... https://wiki.alpinelinux.org/wiki/Main_Page
* (2): `ls packages | wc`
* (3): https://askubuntu.com/questions/120630/how-many-packages-are-in-the-main-repository
* (4): `ls main community non-free | wc`
* (5): yes, but on a separate Git tree... https://git.yoctoproject.org/cgit/cgit.cgi/yocto-docs/
* (6): yes, but the initial Poky build / download still took 5 hours on <<38mbps-internet>>, and QEMU failed to boot at the end... https://bugzilla.yoctoproject.org/show_bug.cgi?id=12953
* (7): `ls recipes-* | wc`
* (8): Poky reference system: http://git.yoctoproject.org/cgit/cgit.cgi/poky

Other interesting possibilities that I haven't evaluated well:

* NixOS https://nixos.org/ Seems to support full build from source well. Not much cross compilation information however.
* Gentoo https://en.wikipedia.org/wiki/Gentoo_Linux Seems to support full build from source well.

=== Soft topics

==== Fairy tale

____
Once upon a time, there was a boy called Linus.

Linus made a super fun toy, and since he was not very humble, decided to call it Linux.

Linux was an awesome toy, but it had one big problem: it was very difficult to learn how to play with it!

As a result, only some weird kids who were very bored ended up playing with Linux, and everyone thought those kids were very cool, in their own weird way.

One day, a mysterious new kid called Ciro tried to play with Linux, and like many before him, got very frustrated, and gave up.

A few years later, Ciro had grown up a bit, and by chance came across a very cool toy made by the boy Petazzoni and his gang: it was called Buildroot.

Ciro noticed that if you used Buildroot together with Linux, and Linux suddenly became very fun to play with!

So Ciro decided to explain to as many kids as possible how to use Buildroot to play with Linux.

And so everyone was happy. Except some of the old weird kernel hackers who wanted to keep their mystique, but so be it.

THE END
____

==== Should you waste your life with systems programming?

Being the hardcore person who fully understands an important complex system such as a computer, it does have a nice ring to it doesn't it?

But before you dedicate your life to this nonsense, do consider the following points:

* almost all contributions to the kernel are done by large companies, and if you are not an employee in one of them, you are likely not going to be able to do much.
+
This can be inferred by the fact that the `devices/` directory is by far the largest in the kernel.
+
The kernel is of course just an interface to hardware, and the hardware developers start developing their kernel stuff even before specs are publicly released, both to help with hardware development and to have things working when the announcement is made.
+
Furthermore, I believe that there are in-tree devices which have never been properly publicly documented. Linus is of course fine with this, since code == documentation for him, but it is not as easy for mere mortals.
+
There are some less hardware bound higher level layers in the kernel which might not require being in a hardware company, and a few people must be living off it.
+
But of course, those are heavily motivated by the underlying hardware characteristics, and it is very likely that most of the people working there were previously at a hardware company.
+
In that sense, therefore, the kernel is not as open as one might want to believe.
* it is impossible to become rich with this knowledge.
+
This is partly implied by the fact that you need to be in a big company to make useful low level things, and therefore you will only be a tiny cog in the engine.
+
The key problem is that the entry cost of hardware design is just too insanely high for startups in general.
* Is learning this the most useful thing that you think can do for society?
+
Or are you just learning it for job security and having a nice sounding title?
+
I'm not a huge fan of the person, but I think Jobs said it right: https://www.youtube.com/watch?v=FF-tKLISfPE
+
First determine the useful goal, and then backtrack down to the most efficient thing you can do to reach it.
* there are two things that sadden me compared to physics-based engineering:
+
--
** you will never become eternally famous. All tech disappears sooner or later, while laws of nature, at least as useful approximations, stay unchanged.
** every problem that you face is caused by imperfections introduced by other humans.
+
It is much easier to accept limitations of physics, and even natural selection in biology, which is are produced by a sentient being (?).
--
+
Physics-based engineering, just like low level hardware, is of course completely closed source however, since wrestling against the laws of physics is about the most expensive thing humans can do.

Are you fine with those points, and ready to continue wasting your life?

Good. In that case, read on, and let's have some fun together ;-)

=== Bibliography

Runnable stuff:

* https://lwn.net/Kernel/LDD3/ the best book, but outdated. Updated source: https://github.com/martinezjavier/ldd3 But examples non-minimal and take too much brain power to understand.
* https://github.com/satoru-takeuchi/elkdat manual build process without Buildroot, very few and simple kernel modules. But it seem ktest + QEMU working, which is awesome. `./test` there patches ktest config dynamically based on CLI! Maybe we should just steal it since GPL licensed.
* https://github.com/tinyclub/linux-lab Buildroot based, no kernel modules?
* https://github.com/agelastic/eudyptula
* https://github.com/linux-kernel-labs Yocto based, source inside a kernel fork subdir: https://github.com/linux-kernel-labs/linux/tree/f08b9e4238dfc612a9d019e3705bd906930057fc/tools/labs which the author would like to upstream https://www.reddit.com/r/programming/comments/79w2q9/linux_device_driver_labs_the_linux_kernel/dp6of43/
* Android AOSP: https://stackoverflow.com/questions/1809774/how-to-compile-the-android-aosp-kernel-and-test-it-with-the-android-emulator/48310014#48310014 AOSP is basically a uber bloated Buildroot (2 hours build vs 30 minutes), Android is Linux based, and QEMU is the emulator backend. These instructions might work for debugging the kernel: https://github.com/Fuzion24/AndroidKernelExploitationPlayground
* https://github.com/s-matyukevich/raspberry-pi-os Does both an OS from scratch, and annotates the corresponding kernel source code. For RPI3, no QEMU support: https://github.com/s-matyukevich/raspberry-pi-os/issues/8
* https://github.com/pw4ever/linux-kernel-hacking-helper as of bd9952127e7eda643cbb6cb4c51ad7b5b224f438, Bash, Arch Linux rootfs
* https://github.com/MichielDerhaeg/build-linux untested. Manually builds musl and BusyBox, no Buildroot. Seems to use host packaged toolchain and tested on x86_64 only. Might contain a minimized kernel config.

Theory:

* http://nairobi-embedded.org you will fall here a lot when you start popping the hard QEMU Google queries. They have covered everything we do here basically, but with a more manual approach, while this repo automates everything.
+
I couldn't find the markup source code for the tutorials, and as a result when the domain went down in May 2018, you have to use http://web.archive.org/ to see the pages...
* https://balau82.wordpress.com awesome low level resource
* https://rwmj.wordpress.com/ awesome red hatter
* https://lwn.net
* http://www.makelinux.net
* https://notes.shichao.io/lkd/

Awesome lists:

* https://github.com/gurugio/lowlevelprogramming-university
* https://github.com/uhub/awesome-c
