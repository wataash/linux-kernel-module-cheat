
:description: The perfect emulation setup to study and develop the <<linux-kernel>> v5.2.1, kernel modules, <<qemu-buildroot-setup,QEMU>>, <<gem5-buildroot-setup,gem5>> and x86_64, ARMv7 and ARMv8 <<userland-assembly,userland>> and <<baremetal-setup,baremetal>> assembly, <<c,ANSI C>>, <<cpp,C++>> and <<posix,POSIX>>. <<gdb>> and <<kgdb>> just work. Powered by <<about-the-qemu-buildroot-setup,Buildroot>> and <<about-the-baremetal-setup,crosstool-NG>>.  Highly automated. Thoroughly documented. Automated <<test-this-repo,tests>>. "Tested" in an Ubuntu 18.04 host.
:idprefix:
:idseparator: -
:nofooter:
:sectanchors:
:sectlinks:
:sectnumlevels: 6
:sectnums:
:toc-title:
:toc: macro
:toclevels: 6

== ARM userland assembly

Arch general getting started at: xref:userland-assembly[xrefstyle=full].

Instructions here loosely grouped based on that of the <<armarm7>> Chapter A4 "The Instruction Sets".

We cover here mostly ARMv7, and then treat aarch64 differentially, since much of the ARMv7 userland is the same in aarch32.

=== Introduction to the ARM architecture

The https://en.wikipedia.org/wiki/ARM_architecture[ARM architecture] is has been used on the vast majority of mobile phones in the 2010's, and on a large fraction of micro controllers.

It competes with <<x86-userland-assembly>> because its implementations are designed for low power consumption, which is a major requirement of the cell phone market.

ARM is generally considered a RISC instruction set, although there are some more complex instructions which would not generally be classified as purely RISC.

ARM is developed by the British funded company ARM Holdings: https://en.wikipedia.org/wiki/Arm_Holdings which originated as a joint venture between Acorn Computers, Apple  and VLSI Technology in 1990.

ARM Holdings was bought by the Japanese giant SoftBank in 2016.

==== ARMv8 vs ARMv7 vs AArch64 vs AArch32

ARMv7 is the older architecture described at: <<armarm7>>.

ARMv8 is the newer architecture ISA https://developer.arm.com/docs/den0024/latest/preface[released in 2013] and described at: <<armarm8>>. It can be in either of two states:

* <<aarch32>>
* aarch64

In the lose terminology of this repository:

* `arm` means basically AArch32
* `aarch64` means ARMv8 AArch64

ARMv8 has https://en.wikipedia.org/wiki/ARM_architecture#ARMv8-A[had several updates] since its release:

* v8.1: 2014
* v8.2: 2016
* v8.3: 2016
* v8.4: TODO
* v8.5: 2018

They are described at: <<armarm8>> A1.7 "ARMv8 architecture extensions".

===== AArch32

32-bit mode of operation of ARMv8.

Userland is highly / fully backwards compatible with ARMv7:

* https://stackoverflow.com/questions/42972096/armv8-backward-compatibility-with-armv7-snapdragon-820-vs-cortex-a15
* https://stackoverflow.com/questions/31848185/does-armv8-aarch32-mode-has-backward-compatible-with-armv4-armv5-or-armv6

For this reason, QEMU and GAS seems to enable both AArch32 and ARMv7 under `arm` rather than `aarch64`.

There are however some extensions over ARMv7, many of them are functionality that ARMv8 has and that designers decided to backport on AArch32 as well, e.g.:

* <<armv8-aarch32-vcvta-instruction>>

===== AArch32 vs AArch64

A great summary of differences can be found at: https://en.wikipedia.org/wiki/ARM_architecture#AArch64_features

Some random ones:

* aarch32 has two encodings: Thumb and ARM: xref:arm-instruction-encodings[xrefstyle=full]
* in ARMv8, the stack can be enforced to 16-byte alignment: xref:armv8-aarch64-stack-alignment[xrefstyle=full]

==== Free ARM implementations

The ARM instruction set is itself protected by patents / copyright / whatever, and you have to pay ARM Holdings a licence to implement it, even if you are creating your own custom Verilog code.

ARM has already sued people in the past for implementing ARM ISA: http://www.eetimes.com/author.asp?section_id=36&doc_id=1287452

http://semiengineering.com/an-alternative-to-x86-arm-architectures/ mentions that:

____
Asanovic joked that the shortest unit of time is not the moment between a traffic light turning green in New York City and the cab driver behind the first vehicle blowing the horn; it’s someone announcing that they have created an open-source, ARM-compatible core and receiving a “cease and desist” letter from a law firm representing ARM.
____

This licensing however does have the following fairness to it: ARM Holdings invents a lot of money in making a great open source software environment for the ARM ISA, so it is only natural that it should be able to get some money from hardware manufacturers for using their ISA.

Patents for very old ISAs however have expired, Amber is one implementation of those: https://en.wikipedia.org/wiki/Amber_%28processor_core%29 TODO does it have any application?


Generally, it is mostly large companies that implement the CPUs themselves. For example, the https://en.wikipedia.org/wiki/Apple_A12[Apple A12 chip], which is used in iPhones, has verilog designs:

____
The A12 features an Apple-designed 64-bit ARMv8.3-A six-core CPU, with two high-performance cores running at 2.49 GHz called Vortex and four energy-efficient cores called Tempest.
____

ARM designed CPUs however are mostly called `Coretx-A<id>`: https://en.wikipedia.org/wiki/List_of_applications_of_ARM_cores Vortex and Tempest are Apple designed ones.
Bibliography: https://www.quora.com/Why-is-it-that-you-need-a-license-from-ARM-to-design-an-ARM-CPU-How-are-the-instruction-sets-protected

==== ARM instruction encodings

Understanding the basics of instruction encodings is fundamental to help you to remember what instructions do and why some things are possible or not, notably the <<arm-ldr-pseudo-instruction>> and the <<arm-adr-instruction,ADRP instruction>>.

aarch32 has two "instruction sets", which to look just like encodings.

The encodings are:

* A32: every instruction is 4 bytes long. Can encode every instruction.
* T32: most common instructions are 2 bytes long. Many others less common ones are 4 bytes long.
+
T stands for "Thumb", which is the original name for the technology, <<armarm8>> A1.3.2 "The ARM instruction sets" says:
+
____
In previous documentation, these instruction sets were called the ARM and Thumb instruction sets
____
+
See also: <<armarm8>> F2.1.3 "Instruction encodings".

Within each instruction set, there can be multiple encodings for a given function, and they are noted simply as:

* A1, A2, ...: A32 encodings
* T1, T2, ..m: T32 encodings

The state bit `PSTATE.T` determines if the processor is in thumb mode or not. <<armarm8>> says that this bit it can only be read from <<arm-bx-instruction>>

https://stackoverflow.com/questions/22660025/how-can-i-tell-if-i-am-in-arm-mode-or-thumb-mode-in-gdb

TODO: details: https://stackoverflow.com/questions/22660025/how-can-i-tell-if-i-am-in-arm-mode-or-thumb-mode-in-gdb says it is `0x20 & CPSR`.

This RISC-y mostly fixed instruction length design likely makes processor design easier and allows for certain optimizations, at the cost of slightly more complex assembly, as you can't encode 4 / 8 byte addresses in a single instruction. Totally worth it IMHO.

This design can be contrasted with x86, which has widely variable instruction length.

We can swap between A32 and T32 with the BX and BLX instructions: http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.kui0100a/armasm_cihfddaf.htm puts it really nicely:

____
* The BL and BLX instructions copy the address of the next instruction into lr (r14, the link register).
* The BX and BLX instructions can change the processor state from ARM to Thumb, or from Thumb to ARM.
** BLX label always changes the state.
** BX Rm and BLX Rm derive the target state from bit[0] of Rm:
*** if bit[0] of Rm is 0, the processor changes to, or remains in, ARM state
*** if bit[0] of Rm is 1, the processor changes to, or remains in, Thumb state.

The BXJ instruction changes the processor state to Jazelle.
____

Bibliography:

* https://stackoverflow.com/questions/28669905/what-is-the-difference-between-the-arm-thumb-and-thumb-2-instruction-encodings

===== ARM Thumb encoding

Thumb examples are available at:

* link:userland/arch/arm/thumb.S[]
* link:userland/arch/arm/freestanding/linux/hello_thumb.S[]

For both of them, we can check that we are in thumb from inside GDB with:

* `disassemble`, and observe that some of the instructions are only 2 bytes long instead of always 4 as in ARM
* `print $cpsr & 0x20` which is `1` on thumb and `0` otherwise

You should contrast those examples with similar non-thumb ones of course.

We also note that thumbness of those sources is determined solely by the `.thumb_func` directive, which implies that there must be some metadata to allow the linker to decide how that code should be called:

* for the freestanding example, this is determined by the first bit of the entry address ELF header as mentioned at: https://stackoverflow.com/questions/20369440/can-start-be-the-thumb-function/20374451#20374451
+
We verify that with:
+
....
./run-toolchain --arch arm readelf -- -h "$(./getvar --arch arm userland_build_dir)/arch/arm/freestanding/linux/hello_thumb.out"
....
+
The Linux kernel must use that to decide put the CPU in thumb mode: that could be done simply with a regular BX.
* on the non-freestanding one, the linker uses some ELF metadata to decide that `main` is thumb and jumps to it appropriately: https://reverseengineering.stackexchange.com/questions/6080/how-to-detect-thumb-mode-in-arm-disassembly
+
TODO details. Does the linker then resolve thumbness with address relocation? Doesn't this imply that the compiler cannot generate BL (never changes) or BLX (always changes) across object files, only BX (target state controlled by lower bit)?

===== ARM big endian mode

ARM can switch between big and little endian mode on the fly!

However, everyone only uses little endian, so the big endian ecosystem is not as supported.

TODO is there any advantage of using big endian?

Here Peter mentions that QEMU does "support" big endian in theory, but that there are no machines for it not sure what that implies: https://stackoverflow.com/questions/41571643/emulatin-big-endian-arm-system-with-qemu

We can try it out quickly in user mode with:

....
touch userland/arch/aarch64/freestanding/linux/hello.S
./build-userland --arch aarch64 --ccflags=-mbig-endian userland/arch/aarch64/freestanding/linux/hello.S
./run --arch aarch64 --userland userland/arch/aarch64/freestanding/linux/hello.S
....

and it fails with:

....
Invalid ELF image for this architecture
....

From this we can guess that the big endian metadata is actually stored in the <<elf>> file, and confirm that with:

....
./run-toolchain \
  --arch aarch64 \
  readelf \
  -- \
  --file-header "$(./getvar --arch aarch64 userland_build_dir)/arch/aarch64/freestanding/linux/hello.out" \
;
....

which contains:

....
Data:                              2's complement, big endian
....

instead of the default:

....
Data:                              2's complement, little endian
....

TODO does the Linux kernel support running big endian executables? I tried after building the big endian executable:

....
./build-buildroot --arch aarch64
./run --arch aarch64 --eval-after ./arch/aarch64/freestanding/linux/hello.out
....

but that failed with:

....
/lkmc/arch/aarch64/freestanding/linux/hello.out: line 1: ELF@x@0@8@: not found
/lkmc/arch/aarch64/freestanding/linux/hello.out: line 2: @@: not found
/lkmc/arch/aarch64/freestanding/linux/hello.out: line 3: syntax error: unexpected ")"
....

TODO:

* can you compile the Linux kernel itself as big endian? Looks like yes since there is a https://github.com/torvalds/linux/blob/v5.1/arch/arm64/Kconfig#L791[`config CPU_BIG_ENDIAN`] See also: https://unix.stackexchange.com/questions/378829/getting-big-endian-linux-build-to-boot-on-arm-with-u-boot
* how can be is the endianess be checked and modified in the CPU?

=== ARM branch instructions

==== ARM B instruction

Unconditional branch.

Example: link:userland/arch/arm/b.S[]

The encoding stores PC offsets in 24 bits. The destination must be a multiple of 4, which is easy since all instructions are 4 bytes.

This allows for 26 bit long jumps, which is 64 MiB.

TODO: what to do if we want to jump longer than that?

==== ARM BEQ instruction

Branch if equal based on the status registers.

Examples:

* link:userland/arch/arm/beq.S[].
* link:userland/arch/aarch64/beq.S[].

The family of instructions includes:

* BEQ: branch if equal
* BNE: branch if not equal
* BLE: less or equal
* BGE: greater or equal
* BLT: less than
* BGT: greater than

==== ARM BL instruction

Branch with link, i.e. branch and store the return address on the RL register.

Example: link:userland/arch/arm/bl.S[]

This is the major way to make function calls.

The current ARM / Thumb mode is encoded in the least significant bit of lr.

===== ARM BX instruction

See: xref:arm-thumb-encoding[xrefstyle=full]

===== ARMv8 aarch64 ret instruction

Example: link:userland/arch/aarch64/ret.S[]

ARMv8 AArch64 only:

* there is no BX in AArch64 since no Thumb to worry about, so it is called just BR
* the RET instruction was added in addition to BR, with the following differences:
** provides a hint that this is a function call return
** has a default argument X30 if none is given. This is where BL puts the return value.

See also: https://stackoverflow.com/questions/32304646/arm-assembly-branch-to-address-inside-register-or-memory/54145818#54145818

==== ARM CBZ instruction

Compare and branch if zero.

Example: link:userland/arch/aarch64/cbz.S[]

Only in ARMv8 and ARMv7 Thumb mode, not in armv7 ARM mode.

Very handy!

==== ARM conditional execution

Weirdly, <<arm-b-instruction>> and family are not the only instructions that can execute conditionally on the flags: the same also applies to most instructions, e.g. ADD.

Example: link:userland/arch/arm/cond.S[]

Just add the usual `eq`, `ne`, etc. suffixes just as for B.

The list of all extensions is documented at <<armarm7>> "A8.3 Conditional execution".

=== ARM load and store instructions

In ARM, there are only two instruction families that do memory access:

* <<arm-ldr-instruction>> to load from memory to registers
* <<arm-str-instruction>> to store from registers to memory

Everything else works on register and immediates.

This is part of the RISC-y beauty of the ARM instruction set, unlike x86 in which several operations can read from memory, and helps to predict how to optimize for a given CPU pipeline.

This kind of architecture is called a https://en.wikipedia.org/wiki/Load/store_architecture[Load/store architecture].

==== ARM LDR instruction

===== ARM LDR pseudo-instruction

LDR can be either a regular instruction that loads stuff into memory, or also a pseudo-instruction (assembler magic): http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0041c/Babbfdih.html

The pseudo instruction version is when an equal sign appears on one of the operators.

The LDR pseudo instruction can automatically create hidden variables in a place called the "literal pool", and load them from memory with PC relative loads.

Example: link:userland/arch/arm/ldr_pseudo.S[]

This is done basically because all instructions are 32-bit wide, and there is not enough space to encode 32-bit addresses in them.

Bibliography:

* https://stackoverflow.com/questions/37840754/what-does-an-equals-sign-on-the-right-side-of-a-ldr-instruction-in-arm-mean
* https://stackoverflow.com/questions/17214962/what-is-the-difference-between-label-equals-sign-and-label-brackets-in-ar
* https://stackoverflow.com/questions/14046686/why-use-ldr-over-mov-or-vice-versa-in-arm-assembly

===== ARM addressing modes

Example: link:userland/arch/arm/address_modes.S[]

Load and store instructions can update the source register with the following modes:

* offset: add an offset, don't change the address register. Notation:
+
....
ldr r1, [r0, 4]
....
* pre-indexed: change the address register, and then use it modified. Notation:
+
....
ldr r1, [r0, 4]!
....
* post-indexed: use the address register unmodified, and then modify it. Notation:
+
....
ldr r1, [r0], 4
....

The offset itself can come from the following sources:

* immediate
* register
* scaled register: left shift the register and use that as an offset

The indexed modes are convenient to loop over arrays.

Bibliography: <<armarm7>>:

* A4.6.5 "Addressing modes"
* A8.5 "Memory accesses"

<<armarm8>>: C1.3.3 "Load/Store addressing modes"

====== ARM loop over array

As an application of the post-indexed addressing mode, let's increment an array.

Example: link:userland/arch/arm/inc_array.S[]

===== ARM LDRH and LDRB instructions

There are LDR variants that load less than full 4 bytes:

* link:userland/arch/arm/ldrb.S[]: load byte
* link:userland/arch/arm/ldrh.S[]: load half word

==== ARM STR instruction

Store from memory into registers.

Example: link:userland/arch/arm/str.S[]

Basically everything that applies to <<arm-ldr-instruction>> also applies here so we won't go into much detail.

===== ARMv8 aarch64 STR instruction

PC-relative STR is not possible in aarch64.

For LDR it works <<arm-ldr-instruction,as in aarch32>>.

As a result, it is not possible to load from the literal pool for STR.

Example: link:userland/arch/aarch64/str.S[]

This can be seen from <<armarm8>> C3.2.1 "Load/Store register": LDR simply has on extra PC encoding that STR does not.

===== ARMv8 aarch64 LDP and STP instructions

Push a pair of registers to the stack.

TODO minimal example. Currently used in `LKMC_PROLOGUE` at link:lkmc/aarch64.h[] since it is the main way to restore register state.

====== ARMV8 aarch64 stack alignment

In ARMv8, the stack can be enforced to 16-byte alignment.

This is why the main way to push things to stack is with 8-byte pair pushes with the <<armv8-aarch64-ldp-and-stp-instructions>>.

<<armarm8-db>> C1.3.3 "Load/Store addressing modes" says:

____
When stack alignment checking is enabled by system software and the base register is the SP, the current stack pointer must be initially quadword aligned, that is aligned to 16 bytes. Misalignment generates a Stack Alignment fault. The offset does not have to be a multiple of 16 bytes unless the specific Load/Store instruction requires this. SP cannot be used as a register offset.
____

<<armarm8-db>> C3.2 "Loads and stores" says:

____
The additional control bits SCTLR_ELx.SA and SCTLR_EL1.SA0 control whether the stack pointer must be quadword aligned when used as a base register. See SP alignment checking on page D1-2164. Using a misaligned stack pointer generates an SP alignment fault exception.
____

<<armarm8-db>> D1.8.2 "SP alignment checking" is then the main section.

TODO: what does the ABI say on this? Why don't I observe faults on QEMU as mentioned at: https://stackoverflow.com/questions/212466/what-is-a-bus-error/31877230#31877230

See also:

* https://stackoverflow.com/questions/38535738/does-aarch64-support-unaligned-access

==== ARM LDMIA instruction

Pop values form stack into the register and optionally update the address register.

STMDB is the push version.

Example: link:userland/arch/arm/ldmia.S[]

The mnemonics stand for:

* STMDB: STore Multiple Decrement Before
* LDMIA: LoaD Multiple Increment After

Example: link:userland/arch/arm/push.S[]

PUSH and POP are just mnemonics STDMDB and LDMIA using the stack pointer SP as address register:

....
stmdb sp!, reglist
ldmia sp!, reglist
....

The `!` indicates that we want to update the register.

The registers are encoded as single bits inside the instruction: each bit represents one register.

As a consequence, the push order is fixed no matter how you write the assembly instruction: there is just not enough space to encode ordering.

AArch64 loses those instructions, likely because it was not possible anymore to encode all registers: https://stackoverflow.com/questions/27941220/push-lr-and-pop-lr-in-arm-arch64 and replaces them with the <<armv8-aarch64-ldp-and-stp-instructions>>

=== ARM data processing instructions

Arithmetic:

* link:userland/arch/arm/mul.S[]: multiply
* link:userland/arch/arm/sub.S[]: subtract
* link:userland/arch/arm/rbit.S[]: reverse bit order
* link:userland/arch/arm/rev.S[]: reverse byte order
* link:userland/arch/arm/tst.S[]

==== ARM CSET instruction

Example: link:userland/arch/aarch64/cset.S[]

Set a register conditionally depending on the condition flags:

ARMv8-only, likely because in ARMv8 you can't have conditional suffixes for every instruction.

==== ARM bitwise instructions

* link:userland/arch/arm/and.S[] AND
* EOR: exclusive OR
* link:userland/arch/arm/orr.S[]: OR
* link:userland/arch/arm/clz.S[]: count leading zeroes

===== ARM BIC instruction

Bitwise Bit Clear: clear some bits.

....
dest = left & ~right
....

Example: link:userland/arch/arm/bic.S[]

===== ARM UBFM instruction

Unsigned Bitfield Move.

____
copies any number of low-order bits from a source register into the same number of adjacent bits at any position in the destination register, with zeros in the upper and lower bits.
____

Example: link:userland/arch/aarch64/ubfm.S[]

TODO: explain full behaviour. Very complicated. Has several simpler to understand aliases.

====== ARM UBFX instruction

Alias for:

....
UBFM <Wd>, <Wn>, #<lsb>, #(<lsb>+<width>-1)
....

Example: link:userland/arch/aarch64/ubfx.S[]

The operation:

....
UBFX dest, src, lsb, width
....

does:

....
dest = (src & ((1 << width) - 1)) >> lsb;
....

Bibliography: https://stackoverflow.com/questions/8366625/arm-bit-field-extract

===== ARM BFM instruction

TODO: explain. Similar to <<arm-ubfm-instruction,UBFM>> but leave untouched bits unmodified.

====== ARM BFI instruction

Examples:

* link:userland/arch/arm/bfi.S[]
* link:userland/arch/aarch64/bfi.S[]

Move the lower bits of source register into any position in the destination:

* ARMv8: an alias for <<arm-bfm-instruction>>
* ARMv7: a real instruction

==== ARM MOV instruction

Move an immediate to a register, or a register to another register.

Cannot load from or to memory, since only the LDR and STR instruction families can do that in ARM as mentioned at: xref:arm-load-and-store-instructions[xrefstyle=full].

Example: link:userland/arch/arm/mov.S[]

Since every instruction <<arm-instruction-encodings,has a fixed 4 byte size>>, there is not enough space to encode arbitrary 32-bit immediates in a single instruction, since some of the bits are needed to actually encode the instruction itself.

The solutions to this problem are mentioned at:

* https://stackoverflow.com/questions/38689886/loading-32-bit-values-to-a-register-in-arm-assembly
* https://community.arm.com/processors/b/blog/posts/how-to-load-constants-in-assembly-for-arm-architecture

Summary of solutions:

* <<arm-movw-and-movt-instructions>>
* place it in memory. But then how to load the address, which is also a 32-bit value?
** use pc-relative addressing if the memory is close enough
** use <<arm-bitwise-instructions,ORR>> encodable shifted immediates

The blog article summarizes nicely which immediates can be encoded and the design rationale:

____
An Operand 2 immediate must obey the following rule to fit in the instruction: an 8-bit value rotated right by an even number of bits between 0 and 30 (inclusive). This allows for constants such as 0xFF (0xFF rotated right by 0), 0xFF00 (0xFF rotated right by 24) or 0xF000000F (0xFF rotated right by 4).

In software - especially in languages like C - constants tend to be small. When they are not small they tend to be bit masks. Operand 2 immediates provide a reasonable compromise between constant coverage and encoding space; most common constants can be encoded directly.
____

Assemblers however support magic memory allocations which may hide what is truly going on: https://stackoverflow.com/questions/14046686/why-use-ldr-over-mov-or-vice-versa-in-arm-assembly Always ask your friendly disassembly for a good confirmation.

===== ARM movw and movt instructions

Set the higher or lower 16 bits of a register to an immediate in one go.

Example: link:userland/arch/arm/movw.S[]

The armv8 version analogue is <<armv8-aarch64-movk-instruction>>.

===== ARMv8 aarch64 movk instruction

Fill a 64 bit register with 4 16-bit instructions one at a time.

Similar to <<arm-movw-and-movt-instructions>> in v7.

Example: link:userland/arch/aarch64/movk.S[]

Bibliography: https://stackoverflow.com/questions/27938768/moving-a-32-bit-constant-in-arm-arch64-register

===== ARMv8 aarch64 movn instruction

Set 16-bits negated and the rest to `1`.

Example: link:userland/arch/aarch64/movn.S[]

==== ARM data processing instruction suffixes

===== ARM shift suffixes

Most data processing instructions can also optionally shift the second register operand.

Example: link:userland/arch/arm/shift.S[]

The shift types are:

* LSR and LFL: Logical Shift Right / Left. Insert zeroes.
* ROR: Rotate Right / Left. Wrap bits around.
* ASR: Arithmetic Shift Right. Keep sign.

Documented at: <<armarm7>> "A4.4.1 Standard data-processing instructions"

===== ARM S suffix

Example: link:userland/arch/arm/s_suffix.S[]

The `S` suffix, present on most <<arm-data-processing-instructions>>, makes the instruction also set the Status register flags that control conditional jumps.

If the result of the operation is `0`, then it triggers BEQ, since comparison is a subtraction, with success on 0.

CMP sets the flags by default of course.

==== ARM ADR instruction

Similar rationale to the <<arm-ldr-pseudo-instruction>>, allowing to easily store a PC-relative reachable address into a register in one go, to overcome the 4-byte fixed instruction size.

Examples:

* link:userland/arch/arm/adr.S[]
* link:userland/arch/aarch64/adr.S[]
* link:userland/arch/aarch64/adrp.S[]

More details: https://stackoverflow.com/questions/41906688/what-are-the-semantics-of-adrp-and-adrl-instructions-in-arm-assembly/54042899#54042899

===== ARM ADRL instruction

See: xref:arm-adr-instruction[xrefstyle=full].

=== ARM miscellaneous instructions

==== ARM NOP instruction

Parent section: xref:nop-instructions[xrefstyle=full]

There are a few different ways to encode NOP, notably MOV a register into itself, and a dedicated miscellaneous instruction.

Example: link:userland/arch/arm/nop.S[]

Try disassembling the executable to see what the assembler is emitting:

....
gdb-multiarch -batch -ex 'arch arm' -ex "file v7/nop.out" -ex "disassemble/rs asm_main_after_prologue"
....

Bibliography: https://stackoverflow.com/questions/1875491/nop-for-iphone-binaries

==== ARM UDF instruction

Guaranteed undefined! Therefore raise illegal instruction signal. Used by GCC `__builtin_trap` apparently: https://stackoverflow.com/questions/16081618/programmatically-cause-undefined-instruction-exception

* link:userland/arch/arm/udf.S[]
* link:userland/arch/aarch64/udf.S[]

Why GNU GAS 2.29 does not have a mnemonic for it in A64 because it is very recent: shows in <<armarm8-db>> but not `ca`.

=== ARM SIMD

Parent section: xref:simd-assembly[xrefstyle=full]

==== ARM VFP

The name for the ARMv7 and AArch32 floating point and SIMD instructions / registers.

Vector Floating Point extension.

TODO I think it was optional in ARMv7, find quote.

VFP has several revisions, named as VFPv1, VFPv2, etc. TODO: announcement dates.

As mentioned at: https://stackoverflow.com/questions/37790029/what-is-difference-between-arm64-and-armhf/48954012#48954012 the Linux kernel shows those capabilities in `/proc/cpuinfo` with flags such as `vfp`, `vfpv3` and others, see:

* https://github.com/torvalds/linux/blob/v4.18/arch/arm/kernel/setup.c#L1199
* https://github.com/torvalds/linux/blob/v4.18/arch/arm64/kernel/cpuinfo.c#L95

When a certain version of VFP is present on a CPU, the compiler prefix typically contains the `hf` characters which stands for Hard Float, e.g.: `arm-linux-gnueabihf`. This means that the compiler will emit VFP instructions instead of just using software implementations.

Bibliography:

* <<armarm7>> Appendix D6 "Common VFP Subarchitecture Specification". It is not part of the ISA, but just an extension. TODO: that spec does not seem to have the instructions documented, and instruction like VMOV just live with the main instructions. Is VMOV part of VFP?
* https://mindplusplus.wordpress.com/2013/06/25/arm-vfp-vector-programming-part-1-introduction/
* https://en.wikipedia.org/wiki/ARM_architecture#Floating-point_(VFP)

===== ARM VFP registers

TODO example

<<armarm8>> E1.3.1 "The SIMD and floating-point register file" Figure E1-1 "SIMD and floating-point register file, AArch32 operation":

....
+-----+-----+-----+
| S0  |     |     |
+-----+ D0  +     |
| S1  |     |     |
+-----+-----+ Q0  |
| S2  |     |     |
+-----+ D1  +     |
| S3  |     |     |
+-----+-----+-----+
| S4  |     |     |
+-----+ D2  +     |
| S5  |     |     |
+-----+-----+ Q1  |
| S6  |     |     |
+-----+ D3  +     |
| S7  |     |     |
+-----+-----+-----+
....

Note how Sn is weirdly packed inside Dn, and Dn weirdly packed inside Qn, likely for historical reasons.

And you can't access the higher bytes at D16 or greater with Sn.

===== ARM VADD instruction

* link:userland/arch/arm/vadd_scalar.S[]: see also: xref:floating-point-assembly[xrefstyle=full]
* link:userland/arch/arm/vadd_vector.S[]: see also: xref:simd-assembly[xrefstyle=full]

===== ARM VCVT instruction

Example: link:userland/arch/arm/vcvt.S[]

Convert between integers and floating point.

<<armarm7>> on rounding:

____
The floating-point to fixed-point operation uses the Round towards Zero rounding mode. The fixed-point to floating-point operation uses the Round to Nearest rounding mode.
____

Notice how the opcode takes two types.

E.g., in our 32-bit float to 32-bit unsigned example we use:

....
vld1.32.f32
....

====== ARM VCVTR instruction

Example: link:userland/arch/arm/vcvtr.S[]

Like <<arm-vcvt-instruction>>, but the rounding mode is selected by the FPSCR.RMode field.

Selecting rounding mode explicitly per instruction was apparently not possible in ARMv7, but was made possible in <<aarch32>> e.g. with <<armv8-aarch32-vcvta-instruction>>.

Rounding mode selection is exposed in the ANSI C standard through https://en.cppreference.com/w/c/numeric/fenv/feround[`fesetround`].

TODO: is the initial rounding mode specified by the ELF standard? Could not find a reference.

====== ARMv8 AArch32 VCVTA instruction

Example: link:userland/arch/arm/vcvt.S[]

Added in ARMv8 <<aarch32>> only, not present in ARMv7.

In ARMv7, to use a non-round-to-zero rounding mode, you had to set the rounding mode with FPSCR and use the R version of the instruction e.g. <<arm-vcvtr-instruction>>.

Now in AArch32 it is possible to do it explicitly per-instruction.

Also there was no ties to away mode in ARMv7. This mode does not exist in C99 either.

==== ARMv8 Advanced SIMD and floating-point support

The <<armarm8>> specifies floating point and SIMD support in the main architecture at A1.5 "Advanced SIMD and floating-point support".

The feature is often refered to simply as "SIMD&FP" throughout the manual.

The Linux kernel shows `/proc/cpuinfo` compatibility as `neon`, which is yet another intermediate name that came up at some point, see: xref:arm-neon[xrefstyle=full].

Vs <<arm-vfp>>: https://stackoverflow.com/questions/4097034/arm-cortex-a8-whats-the-difference-between-vfp-and-neon

===== ARMv8 floating point availability

Support is semi-mandatory. <<armarm8>> A1.5 "Advanced SIMD and floating-point support":

____
ARMv8 can support the following levels of support for Advanced SIMD and floating-point instructions:

- Full SIMD and floating-point support without exception trapping.
- Full SIMD and floating-point support with exception trapping.
- No floating-point or SIMD support. This option is licensed only for implementations targeting specialized markets.

Note: All systems that support standard operating systems with rich application environments provide hardware
support for Advanced SIMD and floating-point. It is a requirement of the ARM Procedure Call Standard for
AArch64, see Procedure Call Standard for the ARM 64-bit Architecture.
____

Therefore it is in theory optional, but highly available.

This is unlike ARMv7, where floating point is completely optional through <<arm-vfp>>.

===== ARM NEON

Just an informal name for the "Advanced SIMD instructions"? Very confusing.

<<armarm8>> F2.9 "Additional information about Advanced SIMD and floating-point instructions" says:

____
The Advanced SIMD architecture, its associated implementations, and supporting software, are commonly referred to as NEON technology.
____

https://developer.arm.com/technologies/neon mentions that is is present on both ARMv7 and ARMv8:

____
NEON technology was introduced to the Armv7-A and Armv7-R profiles. It is also now an extension to the Armv8-A and Armv8-R profiles.
____

==== ARMv8 AArch64 floating point registers

TODO example.

<<armarm8>> B1.2.1 "Registers in AArch64 state" describes the registers:

____
32 SIMD&FP registers, V0 to V31. Each register can be accessed as:

* A 128-bit register named Q0 to Q31.
* A 64-bit register named D0 to D31.
* A 32-bit register named S0 to S31.
* A 16-bit register named H0 to H31.
* An 8-bit register named B0 to B31.
____

Notice how Sn is very different between v7 and v8! In v7 it goes across Dn, and in v8 inside each Dn.

===== ARMv8 aarch64 add vector instruction

link:userland/arch/aarch64/add_vector.S[]

Good first instruction to learn SIMD: <<simd-assembly>>.

===== ARMv8 aarch64 FADD instruction

* link:userland/arch/aarch64/fadd_vector.S[]: see also: xref:simd-assembly[xrefstyle=full]
* link:userland/arch/aarch64/fadd_scalar.S[]: see also: xref:floating-point-assembly[xrefstyle=full]

====== ARM FADD vs VADD

It is very confusing, but FADDS and FADDD in Aarch32 are <<gnu-gas-assembler-arm-unified-syntax,pre-UAL>> for `vadd.f32` and `vadd.f64` which we use in this tutorial, see: xref:arm-vadd-instruction[xrefstyle=full]

The same goes for most ARMv7 mnemonics: `f*` is old, and `v*` is the newer better syntax.

But then, in ARMv8, they decided to use <<armv8-aarch64-fadd-instruction>> as the main floating point add name, and get rid of VADD!

Also keep in mind that fused multiply add is FMADD.

Examples at: xref:simd-assembly[xrefstyle=full]

===== ARMv8 aarch64 ld2 instruction

Example: link:userland/arch/aarch64/ld2.S[]

We can load multiple vectors interleaved from memory in one single instruction!

This is why the `ldN` instructions take an argument list denoted by `{}` for the registers, much like armv7 <<arm-ldmia-instruction>>.

There are analogous LD3 and LD4 instruction.

==== ARM SIMD bibliography

* GNU GAS tests under https://sourceware.org/git/gitweb.cgi?p=binutils-gdb.git;a=tree;f=gas/testsuite/gas/aarch64;hb=00f223631fa9803b783515a2f667f86997e2cdbe[`gas/testsuite/gas/aarch64`]
* https://stackoverflow.com/questions/2851421/is-there-a-good-reference-for-arm-neon-intrinsics
* assembly optimized libraries:
** https://github.com/projectNe10/Ne10

==== ARM SVE

Example: link:userland/arch/aarch64/sve.S[]

Scalable Vector Extension.

aarch64 only, newer than <<arm-neon>>.

It is called Scalable because it does not specify the vector width! Therefore we don't have to worry about new vector width instructions every few years! Hurray!

The instructions then allow implicitly tracking the loop index without knowing the actual vector length.

Added to QEMU use mode in 3.0.0.

TODO announcement date. Possibly 2017: https://alastairreid.github.io/papers/sve-ieee-micro-2017.pdf There is also a 2016 mention: https://community.arm.com/tools/hpc/b/hpc/posts/technology-update-the-scalable-vector-extension-sve-for-the-armv8-a-architecture

The Linux kernel shows `/proc/cpuinfo` compatibility as `sve`.

Official spec: https://developer.arm.com/docs/100891/latest/sve-overview/introducing-sve

SVE support is indicated by `ID_AA64PFR0_EL1.SVE` which is dumped from link:baremetal/arch/aarch64/dump_regs.c[].

Using SVE normally requires setting the CPACR_EL1.FPEN and ZEN bits, which as as of lkmc 29fd625f3fda79f5e0ee6cac43517ba74340d513 + 1 we also enable in our <<baremetal-bootloaders>>, see also: <<aarch64-baremetal-neon-setup>>.

===== SVE bibliography

* https://www.rico.cat/files/ICS18-gem5-sve-tutorial.pdf step by step of a complete code execution examples, the best initial tutorial so far
* https://alastairreid.github.io/papers/sve-ieee-micro-2017.pdf paper with some nice few concrete examples, illustrations and rationale
* https://static.docs.arm.com/dui0965/c/DUI0965C_scalable_vector_extension_guide.pdf
* https://developer.arm.com/products/software-development-tools/hpc/documentation/writing-inline-sve-assembly quick inlining guide

====== SVE spec

<<armarm8>> A1.7 "ARMv8 architecture extensions" says:

____
SVE is an optional extension to ARMv8.2. That is, SVE requires the implementation of ARMv8.2.
____

A1.7.8 "The Scalable Vector Extension (SVE)": then says that only changes to the existing registers are described in that manual, and that you should look instead at the "ARM Architecture Reference Manual Supplement, The Scalable Vector Extension (SVE), for ARMv8-A."

We then download the zip from: https://developer.arm.com/docs/ddi0584/latest/arm-architecture-reference-manual-supplement-the-scalable-vector-extension-sve-for-armv8-a and it contains the PDF: `DDI0584A_d_SVE_supp_armv8A.pdf` which we use here.

That document then describes the SVE instructions and registers.

=== ARMv8 architecture extensions

==== ARMv8.1 architecture extension

<<armarm8-db>> A1.7.3 "The ARMv8.1 architecture extension"

[[arm-lse]]
===== ARM Large System Extensions (LSE)

<<armarm8-db>> "ARMv8.1-LSE, ARMv8.1 Large System Extensions"

* LDADD: link:userland/cpp/atomic.cpp[]

Bibliography:

* https://stackoverflow.com/questions/21535058/arm64-ldxr-stxr-vs-ldaxr-stlxr
* https://preshing.com/20120710/memory-barriers-are-like-source-control-operations/

=== ARM assembly bibliography

==== ARM non-official bibliography

Good getting started tutorials:

* http://www.davespace.co.uk/arm/introduction-to-arm/
* https://azeria-labs.com/writing-arm-assembly-part-1/
* https://thinkingeek.com/arm-assembler-raspberry-pi/
* http://bob.cs.sonoma.edu/IntroCompOrg-RPi/app-make.html

==== ARM official bibliography

The official manuals were stored in http://infocenter.arm.com but as of 2017 they started to slowly move to https://developer.arm.com[].

Each revision of a document has a "ARM DDI" unique document identifier.

The "ARM Architecture Reference Manuals" are the official canonical ISA documentation document. In this repository, we always reference the following revisions:

Bibliography: https://www.quora.com/Where-can-I-find-the-official-documentation-of-ARM-instruction-set-architectures-ISAs

[[armarm7]]
===== ARMv7 architecture reference manual

https://developer.arm.com/products/architecture/a-profile/docs/ddi0406/latest/arm-architecture-reference-manual-armv7-a-and-armv7-r-edition

The official comprehensive ARMv7 reference.

We use by default: DDI 0406C.d: https://static.docs.arm.com/ddi0406/cd/DDI0406C_d_armv7ar_arm.pdf

[[armarm8]]
===== ARMv8 architecture reference manual

https://static.docs.arm.com/ddi0487/ca/DDI0487C_a_armv8_arm.pdf

Latest version: https://developer.arm.com/docs/ddi0487/latest/arm-architecture-reference-manual-armv8-for-armv8-a-architecture-profile

Versions are determined by two letteres in lexicographical order, e.g.:

* a
* af
* aj
* aj
* b
* ba
* bb
* ca

The link: https://static.docs.arm.com/ddi0487/ca/DDI0487C_a_armv8_arm.pdf is the `ca` version for example.

The official comprehensive ARMv8 reference.

ISA quick references can be found in some places:

* https://web.archive.org/web/20161009122630/http://infocenter.arm.com/help/topic/com.arm.doc.qrc0001m/QRC0001_UAL.pdf

[[armarm8-db]]
===== ARMv8 architecture reference manual db

https://static.docs.arm.com/ddi0487/db/DDI0487D_b_armv8_arm.pdf

[[armv8-programmers-guide]]
===== Programmer's Guide for ARMv8-A

https://static.docs.arm.com/den0024/a/DEN0024A_v8_architecture_PG.pdf

A more terse human readable introduction to the ARM architecture than the reference manuals.

Does not have as many assembly code examples as you'd hope however...

Latest version at: https://developer.arm.com/docs/den0024/latest/preface

===== Arm A64 Instruction Set Architecture: Future Architecture Technologies in the A architecture profile Documentation

https://developer.arm.com/docs/ddi0602/b

This page contains the documentation of architecture features that were publicly announced but haven't been merged into the main spec yet.

===== ARM processor documentation

ARM also releases documentation specific to each given processor.

This adds extra details to the more portable <<armarm8>> ISA documentation.

[[arm-cortex15-trm]]
====== ARM Cortex-A15 MPCore Processor Technical Reference Manual r4p0

http://infocenter.arm.com/help/topic/com.arm.doc.ddi0438i/DDI0438I_cortex_a15_r4p0_trm.pdf

2013.

